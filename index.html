<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ü•î Potato Benchmark ‚Äî MongoDB vs Redis</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg: #050510;
      --surface: rgba(26, 26, 46, 0.7);
      --surface-2: rgba(22, 33, 62, 0.8);
      --mongo: #39ff14;
      --mongo-idx: #00ffcc;
      --redis: #ff00ff;
      --text: #ffffff;
      --text-muted: #b0b0d0;
      --accent: #00f3ff;
      --border: rgba(0, 243, 255, 0.2);
      --glow: 0 0 10px var(--accent), 0 0 20px var(--accent);
    }

    body.cyber-neon {
      --bg: #000000;
      --surface: rgba(10, 10, 30, 0.85);
      --accent: #ff00ff;
      --border: rgba(255, 0, 255, 0.4);
    }
    
    body.potato-glitch {
      --bg: #2d1b0d;
      --accent: #f39c12;
      --border: rgba(243, 156, 18, 0.5);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      overflow-x: hidden;
      transition: background 0.5s ease;
    }

    #canvas-bg {
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      z-index: -1;
      pointer-events: none;
    }

    .header {
      padding: 4rem 1rem;
      text-align: center;
      position: relative;
    }
    
    .glitch {
      font-size: clamp(2rem, 8vw, 3.5rem);
      font-weight: 800;
      text-transform: uppercase;
      position: relative;
      text-shadow: 0.05em 0 0 #ff00ff, -0.05em -0.025em 0 #00ffff, 0.025em 0.05em 0 #39ff14;
      animation: glitch 1s infinite;
      margin-bottom: 0.5rem;
    }
    
    @keyframes glitch {
      0%, 14%, 49%, 99%, 100% { text-shadow: 0.05em 0 0 #ff00ff, -0.05em -0.025em 0 #00ffff, 0.025em 0.05em 0 #39ff14; }
      15% { text-shadow: -0.05em -0.025em 0 #ff00ff, 0.025em 0.025em 0 #00ffff, -0.05em -0.05em 0 #39ff14; }
      50% { text-shadow: 0.025em 0.05em 0 #ff00ff, 0.05em 0 0 #00ffff, 0 -0.05em 0 #39ff14; }
    }

    .theme-switch {
      position: absolute;
      top: 1rem; right: 1rem;
      display: flex; gap: 0.5rem;
      z-index: 200;
    }
    .theme-btn {
      background: var(--surface-2);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 0.4rem 0.8rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.65rem;
      font-weight: 800;
      text-transform: uppercase;
      transition: all 0.3s;
    }
    .theme-btn:hover { box-shadow: var(--glow); transform: scale(1.05); }

    .main {
      max-width: 1000px;
      margin: 0 auto;
      padding: 0 1.5rem 4rem;
    }

    .tabs-nav {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      margin-bottom: 2.5rem;
      background: rgba(0, 0, 0, 0.3);
      padding: 0.5rem;
      border-radius: 50px;
      border: 1px solid var(--border);
      width: fit-content;
      margin-left: auto;
      margin-right: auto;
      backdrop-filter: blur(10px);
    }
    .tab-btn {
      background: transparent;
      border: none;
      color: var(--text-muted);
      padding: 0.6rem 1.2rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      cursor: pointer;
      border-radius: 25px;
      transition: all 0.3s;
      font-size: 0.75rem;
    }
    .tab-btn:hover { color: var(--text); }
    .tab-btn.active {
      background: var(--accent);
      color: #000;
      box-shadow: var(--glow);
    }

    .tab-content { display: none; }
    .tab-content.active { display: block; animation: fadeIn 0.4s ease; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

    .report-wrap {
      background: var(--surface);
      backdrop-filter: blur(15px);
      border: 1px solid var(--border);
      padding: 2.5rem;
      border-radius: 24px;
      box-shadow: 0 0 50px rgba(0, 0, 0, 0.2);
    }
    
    .report-wrap h1 { font-size: 1.8rem; margin-bottom: 1rem; }
    .report-wrap h2 { font-size: 1.4rem; margin-top: 2.5rem; margin-bottom: 1rem; color: var(--accent); }

    .scenario-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 1.5rem;
      margin-top: 2rem;
    }
    
    .scenario-card {
      background: var(--surface);
      backdrop-filter: blur(10px);
      border: 1px solid var(--border);
      padding: 1.5rem;
      border-radius: 16px;
      position: relative;
      overflow: hidden;
      transition: transform 0.3s, box-shadow 0.3s;
    }
    .scenario-card:hover { transform: translateY(-5px); box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4); }
    
    .scenario-card h3 { font-size: 1rem; color: var(--accent); margin-bottom: 0.5rem; }
    .scenario-card .desc { font-size: 0.8rem; color: var(--text-muted); margin-bottom: 1.5rem; }
    .scenario-card .chart-wrap { height: 200px; }

    .chart-container { height: 400px; margin-top: 1rem; }
    .report-chart-box { height: 350px; margin: 2rem 0; }

    .analysis-box {
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1.5rem;
      margin: 1.5rem 0;
    }
    .analysis-box h4 { color: var(--accent); font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 0.5rem; }

    .decision-matrix { display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-top: 2rem; }
    
    .highlight { color: var(--accent); font-weight: 600; text-shadow: 0 0 5px var(--accent); }
    .winner-tag {
      display: inline-block; margin-top: 1rem; padding: 0.3rem 0.8rem;
      border-radius: 20px; font-size: 0.7rem; font-weight: 800; text-transform: uppercase;
    }
    .winner-mongo { background: rgba(57, 255, 20, 0.15); color: var(--mongo); }
    .winner-mongoIdx { background: rgba(0, 255, 204, 0.15); color: var(--mongo-idx); }
    .winner-redis { background: rgba(255, 0, 255, 0.15); color: var(--redis); }

    .table-section { overflow-x: auto; margin-top: 3rem; }
    table { width: 100%; border-collapse: collapse; min-width: 600px; }
    th { text-align: left; padding: 1rem; font-size: 0.7rem; text-transform: uppercase; color: var(--text-muted); border-bottom: 1px solid var(--border); }
    td { padding: 1rem; font-size: 0.85rem; border-bottom: 1px solid var(--border); }

    .stat-card {
      background: var(--surface);
      border: 1px solid var(--border);
      padding: 1.5rem;
      border-radius: 16px;
      text-align: center;
      flex: 1;
      min-width: 120px;
    }
    .stats-bar { display: flex; flex-wrap: wrap; gap: 1rem; margin-bottom: 2rem; }
    .stat-card .value { display: block; font-size: 1.5rem; font-weight: 800; color: var(--accent); }
    .stat-card .label { font-size: 0.6rem; text-transform: uppercase; color: var(--text-muted); }

    @media (max-width: 768px) {
      .decision-matrix { grid-template-columns: 1fr; }
      .tabs-nav { gap: 0.5rem; padding: 0.4rem; }
      .tab-btn { padding: 0.5rem 0.8rem; font-size: 0.65rem; }
      .header { padding: 2.5rem 1rem; }
      .theme-switch { position: static; justify-content: center; margin-bottom: 1rem; }
    }

    /* Global Glitch Effects */
    body.glitch-active .scenario-card,
    body.glitch-active .stat-card {
      animation: glitch-jitter 0.2s infinite;
    }
    
    body.glitch-active .glitch {
      animation: glitch 0.3s infinite;
    }

    body.glitch-active canvas#canvas-bg {
      filter: hue-rotate(90deg) brightness(1.5);
    }

    @keyframes glitch-jitter {
      0% { transform: translate(0); }
      20% { transform: translate(-2px, 1px); }
      40% { transform: translate(-2px, -1px); }
      60% { transform: translate(2px, 1px); }
      80% { transform: translate(2px, -1px); }
      100% { transform: translate(0); }
    }
  </style>
</head>
<body>
<canvas id="canvas-bg"></canvas>

<div class="header">
  <div class="theme-switch">
    <button class="theme-btn" id="glitch-toggle" onclick="toggleGlitch()">Glitch: OFF</button>
    <button class="theme-btn" onclick="setTheme('default')">Basic</button>
    <button class="theme-btn" onclick="setTheme('cyber-neon')">Cyber</button>
    <button class="theme-btn" onclick="setTheme('potato-glitch')">Potato</button>
  </div>
  <h1 class="glitch">ü•î Potato Benchmark</h1>
  <p>Analyse NoSQL de Haute Voltige & Performance Radicale</p>
</div>

<div class="tabs-nav">
  <button class="tab-btn active" id="btn-report" onclick="switchTab('report')">üìñ Rapport d'Analyse</button>
  <button class="tab-btn" id="btn-benchmark" onclick="switchTab('benchmark')">üìä Run Actuel (45M)</button>
  <button class="tab-btn" id="btn-history" onclick="switchTab('history')">üï∞Ô∏è Historique (500k)</button>
</div>

<div id="report-tab" class="tab-content active">
  <div class="main">
    <div class="report-wrap">
      <h1>üìã √âtude Comparative : MongoDB vs Redis</h1>
      <p>Ce benchmark analyse les performances de deux g√©ants du NoSQL face √† un volume de donn√©es massif : <span class="highlight">45 millions de matchs</span> g√©n√©r√©s par <span class="highlight">10 000 patates</span>.</p>

      <div class="report-chart-box"><canvas id="report-chart-overview"></canvas></div>

      <h2>üöÄ Phase 1 : Ingestion et √âcriture (Throughput)</h2>
      <div class="analysis-box">
        <h4>Sc√©narios : INSERT Potatoes & INSERT Matches</h4>
        <p><strong>MongoDB</strong> brille par sa capacit√© d'absorption brute. Avec un temps d'environ <span class="highlight">~115s</span> pour 45M de records, il surclasse Redis (<span class="highlight">~300s</span>) sur l'√©criture initiale. </p>
        <p class="desc">Pourquoi ? MongoDB utilise des buffers m√©moire tr√®s agressifs et un format BSON optimis√© pour le streaming, tandis que Redis subit l'overhead du protocole r√©seau sur des millions de petits objets individuels.</p>
      </div>
      <div class="report-chart-box"><canvas id="report-chart-insertion"></canvas></div>

      <h2>üîç Phase 2 : Latence et CRUD Unitaire</h2>
      <div class="analysis-box">
        <h4>Sc√©narios : READ One & UPDATE Trait</h4>
        <p>Ici, c'est le domaine de <strong>Redis</strong>. La lecture par cl√© est pratiquement instantan√©e (<span class="highlight">~2ms</span>). MongoDB suit de pr√®s avec ses index (<span class="highlight">~4-6ms</span>), mais la diff√©rence de paradigme (RAM vs Disk-backed) reste visible.</p>
        <p class="desc">Commentaire : Redis √©vite tout acc√®s disque (In-Memory). MongoDB, m√™me avec des index, doit parfois effectuer des lectures de pages en RAM qui ajoutent quelques millisecondes de latence syst√®me.</p>
      </div>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem;">
        <div class="report-chart-box" style="height: 250px;"><canvas id="report-chart-read"></canvas></div>
        <div class="report-chart-box" style="height: 250px;"><canvas id="report-chart-delete"></canvas></div>
      </div>

      <h2>üßπ Phase 3 : Suppression Massive (Cleanup)</h2>
      <div class="analysis-box">
        <h4>Sc√©nario : DELETE Cascade</h4>
        <p><strong>Redis</strong> est environ <span class="highlight">6000 fois plus rapide</span>. Il supprime les liens en <span class="highlight">6ms</span> l√† o√π MongoDB n√©cessite <span class="highlight">~36 secondes</span>.</p>
        <p class="desc">Analyse : Dans MongoDB, supprimer une entit√© et ses r√©f√©rences n√©cessite un scan d'index et des r√©-√©critures massives sur disque. Redis g√®re cela presque int√©gralement en m√©moire vive.</p>
      </div>

      <h2>üìä Phase 4 : Statistiques et Agr√©gations</h2>
      
      <div class="analysis-box">
        <h4>Sc√©nario : Leaderboards (Top 10 Winrate)</h4>
        <p>Gr√¢ce aux <code>Sorted Sets</code> (ZSET), le classement dans <strong>Redis</strong> est maintenu en temps r√©el. La lecture prend donc <span class="highlight">~60ms</span>.</p>
        <p><strong>MongoDB</strong> doit calculer le winrate √† la vol√©e sur 45M de matchs, ce qui prend <span class="highlight">~95 secondes</span> sans une vue mat√©rialis√©e.</p>
      </div>
      <div class="report-chart-box"><canvas id="report-chart-winrate"></canvas></div>

      <div class="analysis-box">
        <h4>Sc√©narios : Calculs de Masse (AVG/SUM/COUNT/GROUP)</h4>
        <p>Pour des calculs transversaux, <strong>MongoDB</strong> est le roi de l'analytique gr√¢ce √† son moteur d'agr√©gation natif (<span class="highlight">~8ms √† ~30ms</span>).</p>
        <p class="desc">L'√©chec de Redis : Sans agr√©gation native transverse, Redis doit it√©rer sur chaque objet en RAM (<span class="highlight">~200-300ms</span>), illustrant sa limite pour le "Big Data" analytique pur.</p>
      </div>
      <div class="report-chart-box"><canvas id="report-chart-analytics"></canvas></div>

      <div class="analysis-box">
        <h4>Sc√©narios : Recherche Complexe (SELECT WHERE & MIN/MAX)</h4>
        <p><strong>MongoDB Indexed</strong> est indispensable ici. Trouver les patates les plus fortes via un index se fait en <span class="highlight">4ms</span>. Redis (via scan JS) reste √† 180ms+.</p>
      </div>

      <div style="margin-top: 4rem; padding: 2.5rem; background: var(--surface-2); border: 2px solid var(--accent); border-radius: 20px;">
        <h2 style="margin-top: 0;">üí° Conclusion : Comment choisir ?</h2>
        <p>Le choix d√©pend de votre <strong>mode d'acc√®s aux donn√©es</strong> :</p>
        
        <div class="decision-matrix">
          <div>
            <h4 style="color:var(--redis)">Optez pour Redis si...</h4>
            <ul style="font-size: 0.9rem;">
              <li>Vous avez besoin de <strong>latence ultra-faible</strong> (< 1ms).</li>
              <li>Votre logique repose sur des <strong>classements temps-r√©el</strong>.</li>
              <li>Vous g√©rez des <strong>sessions</strong> ou des donn√©es √©ph√©m√®res.</li>
            </ul>
          </div>
          <div>
            <h4 style="color:var(--mongo)">Optez pour MongoDB si...</h4>
            <ul style="font-size: 0.9rem;">
              <li>Vous avez un <strong>volume massif</strong> d√©passant votre RAM.</li>
              <li>Vous devez faire du <strong>reporting complexe</strong>.</li>
              <li>Vos requ√™tes sont <strong>adhoc</strong> (filtres variables).</li>
            </ul>
          </div>
        </div>
        <p style="text-align: center; margin-top: 2rem; font-weight: 800; border-top: 1px solid var(--border); padding-top: 1rem;">
          üöÄ <span class="highlight">Best Practice</span> : Utilisez les deux ! MongoDB pour le stockage durable, Redis pour le cache et les leaderboards.
        </p>
      </div>
    </div>
  </div>
</div>

<div id="benchmark-tab" class="tab-content">
  <div id="stats-bar-benchmark" class="stats-bar"></div>
  <div class="main" id="app-benchmark">
    <div class="loading"><div class="spinner"></div><p>Chargement des r√©sultats 45M...</p></div>
  </div>
</div>

<div id="history-tab" class="tab-content">
  <div id="stats-bar-history" class="stats-bar"></div>
  <div class="main" id="app-history">
    <div class="loading"><div class="spinner"></div><p>Chargement de l'historique 500k...</p></div>
  </div>
</div>

<div class="footer"><p>Potato Benchmark ‚Äî Cours Opti BDD ‚Äî <span id="timestamp"></span></p></div>

<script>
  let mainData = null;
  let historyData = null;
  const renderedTabs = new Set();
  let glitchEnabled = localStorage.getItem('glitch-active') === 'true';

  function toggleGlitch() {
    glitchEnabled = !glitchEnabled;
    document.body.classList.toggle('glitch-active', glitchEnabled);
    localStorage.setItem('glitch-active', glitchEnabled);
    document.getElementById('glitch-toggle').textContent = `Glitch: ${glitchEnabled ? 'ON' : 'OFF'}`;
    if (glitchEnabled) document.body.classList.add('glitch-active');
    else document.body.classList.remove('glitch-active');
  }

  // Init glitch state
  if (glitchEnabled) {
    document.body.classList.add('glitch-active');
    setTimeout(() => {
        const btn = document.getElementById('glitch-toggle');
        if (btn) btn.textContent = 'Glitch: ON';
    }, 100);
  }

  function switchTab(tab) {
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    
    document.getElementById(`btn-${tab}`).classList.add('active');
    document.getElementById(`${tab}-tab`).classList.add('active');

    if (tab === 'benchmark' && !renderedTabs.has('benchmark')) {
      renderApp(mainData, 'benchmark');
      renderedTabs.add('benchmark');
    } else if (tab === 'history' && !renderedTabs.has('history')) {
      loadAndRender('./history-results.json', 'history');
    }
  }

  const DBS = [
    { key: 'mongoTimeMs',        label: 'MongoDB',          color: '#00ed64', bg: 'rgba(0, 237, 100, 0.7)',   cls: 'mongo' },
    { key: 'mongoIndexedTimeMs', label: 'MongoDB (Index√©)', color: '#00ed64', bg: 'rgba(0, 237, 100, 0.4)',   cls: 'mongoIdx' },
    { key: 'redisTimeMs',        label: 'Redis',            color: '#ff4438', bg: 'rgba(255, 68, 56, 0.7)',   cls: 'redis' },
  ];

  async function loadData(url) {
    try {
      const res = await fetch(url);
      if (!res.ok) throw new Error('not found');
      return await res.json();
    } catch { return null; }
  }

  function getWinner(r) {
    const candidates = DBS.filter(db => db.cls !== 'cassandra' && r[db.key] > 0);
    let best = candidates[0];
    if (!best) return { label: 'N/A', cls: 'none' };
    for (const db of candidates) { 
      if (r[db.key] < r[best.key]) best = db; 
    }
    return best;
  }

  function createChart(id, type, labels, datasets, options = {}) {
    const canvas = document.getElementById(id);
    if (!canvas) return;
    return new Chart(canvas, {
      type: type,
      data: { labels, datasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { 
            display: datasets.length > 1,
            labels: { color: '#e0e0e0', font: { family: 'Inter', size: 10 } } 
          }
        },
        scales: {
          x: { ticks: { color: '#8892b0', font: { size: 10, weight: '600' } }, grid: { color: 'rgba(0, 243, 255, 0.1)' } },
          y: { ticks: { color: '#8892b0', font: { size: 10, weight: '600' } }, grid: { color: 'rgba(0, 243, 255, 0.1)' } }
        },
        ...options
      }
    });
  }

  function renderReportCharts(data) {
    const results = data.results;
    
    // 1. Overview
    createChart('report-chart-overview', 'bar', results.map(r => r.scenario), 
      DBS.map(db => ({
        label: db.label,
        data: results.map(r => r[db.key]),
        backgroundColor: db.bg
      })), 
      { scales: { y: { type: 'logarithmic' } } }
    );

    // 2. Ingestion (INSERT Matches)
    const ins = results.find(r => r.scenario.includes('INSERT Matches'));
    if (ins) {
      createChart('report-chart-insertion', 'bar', DBS.map(d => d.label), 
        [{ data: DBS.map(db => ins[db.key]), backgroundColor: DBS.map(d => d.bg) }],
        { plugins: { legend: { display: false } }, scales: { y: { type: 'logarithmic' } } }
      );
    }

    // 3. Latency (READ + DELETE) - SPLIT for better scales
    const read = results.find(r => r.scenario.includes('READ One'));
    const del = results.find(r => r.scenario.includes('DELETE'));
    if (read) {
      createChart('report-chart-read', 'bar', DBS.slice(0, 3).map(d => d.label), 
        [{ label: 'READ One (ms)', data: DBS.slice(0, 3).map(db => read[db.key]), backgroundColor: DBS.slice(0, 3).map(db => db.bg) }],
        { plugins: { legend: { display: false } }, scales: { y: { type: 'logarithmic', title: { display: true, text: 'ms (Log)' } } } }
      );
    }
    if (del) {
      createChart('report-chart-delete', 'bar', DBS.slice(0, 3).map(d => d.label), 
        [{ label: 'DELETE Cascade (ms)', data: DBS.slice(0, 3).map(db => del[db.key]), backgroundColor: DBS.slice(0, 3).map(db => db.bg) }],
        { plugins: { legend: { display: false } }, scales: { y: { type: 'logarithmic', title: { display: true, text: 'ms (Log)' } } } }
      );
    }

    // 4. Winrate
    const win = results.find(r => r.scenario.includes('Winrate'));
    if (win) {
      createChart('report-chart-winrate', 'bar', DBS.slice(0, 3).map(d => d.label), 
        [{ data: DBS.slice(0, 3).map(db => win[db.key]), backgroundColor: DBS.slice(0, 3).map(d => d.bg) }],
        { plugins: { legend: { display: false } }, scales: { y: { type: 'logarithmic' } } }
      );
    }

    // 5. Analytics (AVG + COUNT)
    const avg = results.find(r => r.scenario.includes('AVG'));
    const cnt = results.find(r => r.scenario.includes('COUNT'));
    if (avg && cnt) {
      createChart('report-chart-analytics', 'bar', ['AVG Stats', 'COUNT WHERE'], 
        DBS.slice(0, 3).map(db => ({
          label: db.label,
          data: [avg[db.key], cnt[db.key]],
          backgroundColor: db.bg
        })),
        { scales: { y: { type: 'logarithmic' } } }
      );
    }
  }

  function renderStatsBar(data, suffix) {
    const bar = document.getElementById(`stats-bar-${suffix}`);
    if (!bar) return;
    const wins = {};
    DBS.forEach(db => wins[db.cls] = 0);
    data.results.forEach(r => wins[getWinner(r).cls]++);

    bar.innerHTML = `
      <div class="stat-card"><span class="value">${data.potatoCount.toLocaleString()}</span><span class="label">Patates</span></div>
      <div class="stat-card"><span class="value">${data.matchCount.toLocaleString()}</span><span class="label">Matchs</span></div>
      <div class="stat-card"><span class="value">${data.results.length}</span><span class="label">Sc√©narios</span></div>
      ${DBS.map(db => `<div class="stat-card"><span class="value" style="color:${db.color}">${wins[db.cls]}</span><span class="label">${db.label}</span></div>`).join('')}
    `;
  }

  function renderApp(data, suffix) {
    const app = document.getElementById(`app-${suffix}`);
    if (!app) return;
    if (suffix === 'benchmark') {
      document.getElementById('timestamp').textContent = new Date(data.timestamp).toLocaleString('fr-FR');
    }

    let cards = '';
    data.results.forEach((r, i) => {
      const w = getWinner(r);
      const scaling = historyData ? historyData.results.find(h => h.scenario === r.scenario) : null;
      
      cards += `
        <div class="scenario-card">
          <h3>${r.scenario}</h3>
          <p class="desc">${r.description}${scaling ? ' <span class="highlight">(Comparison vs 500k active)</span>' : ''}</p>
          <div class="chart-wrap"><canvas id="chart-${suffix}-${i}"></canvas></div>
          <span class="winner-tag winner-${w.cls}">üèÜ Gagnant 45M: ${w.label} (${r[w.key]}ms)</span>
        </div>`;
    });

    app.innerHTML = `
      <div class="scenario-grid">${cards}</div>
      <div class="overview-section">
        <h2>üìä Vue d'ensemble (${suffix}) ‚Äî √©chelle logarithmique</h2>
        <div class="chart-container"><canvas id="overviewChart-${suffix}"></canvas></div>
      </div>
      <div class="table-section">
        <h2>üìã Tableau d√©taill√© (${suffix})</h2>
        <table>
          <thead><tr>
            <th>Sc√©nario</th><th>Description</th>
            ${DBS.map(db => `<th>${db.label} (ms)</th>`).join('')}
            <th>Gagnant</th>
          </tr></thead>
          <tbody id="detailsBody-${suffix}"></tbody>
        </table>
      </div>
    `;

    data.results.forEach((r, i) => {
      const scaling = (suffix === 'benchmark' && historyData) ? historyData.results.find(h => h.scenario === r.scenario) : null;
      const datasets = [];
      
      // Dataset 1: Current Run
      datasets.push({
        label: scaling ? 'Actuel (45M)' : 'R√©sultat',
        data: DBS.map(db => r[db.key]),
        backgroundColor: DBS.map(db => db.bg),
        borderColor: DBS.map(db => db.color),
        borderWidth: 1,
        borderRadius: 4
      });

      // Dataset 2: Scaling (Historical 500k)
      if (scaling) {
        datasets.push({
          label: 'Historique (500k)',
          data: DBS.map(db => scaling[db.key]),
          backgroundColor: DBS.map(db => db.bg.replace('0.7', '0.25').replace('0.4', '0.15')),
          borderColor: DBS.map(db => db.color),
          borderWidth: 1,
          borderDash: [5, 5],
          borderRadius: 4
        });
      }

      createChart(`chart-${suffix}-${i}`, 'bar', DBS.map(db => db.label), datasets, {
        scales: { 
          x: { grid: { display: false } },
          y: { type: 'logarithmic' }
        }
      });
    });

    createChart(`overviewChart-${suffix}`, 'bar', data.results.map(r => r.scenario), 
      DBS.map(db => ({ label: db.label, data: data.results.map(r => r[db.key]), backgroundColor: db.bg })),
      { scales: { y: { type: 'logarithmic' } } }
    );

    const tbody = document.getElementById(`detailsBody-${suffix}`);
    for (const r of data.results) {
      const w = getWinner(r);
      const row = document.createElement('tr');
      row.innerHTML = `
        <td><strong>${r.scenario}</strong></td>
        <td>${r.description}</td>
        ${DBS.map(db => `<td class="c-${db.cls}">${r[db.key] >= 0 ? r[db.key].toLocaleString() : 'N/A'}</td>`).join('')}
        <td><span class="badge badge-${w.cls}">üèÜ ${w.label}</span></td>
      `;
      tbody.appendChild(row);
    }
  }

  async function loadAndRender(url, suffix) {
    const data = await loadData(url);
    if (!data) return;
    renderStatsBar(data, suffix);
    renderApp(data, suffix);
    renderedTabs.add(suffix);
  }

  async function init() {
    mainData = await loadData('./benchmark-results.json');
    historyData = await loadData('./history-results.json');
    
    if (mainData) {
      document.getElementById('timestamp').textContent = new Date(mainData.timestamp).toLocaleString('fr-FR');
      renderReportCharts(mainData);
    }
    initBackground();
  }

  function setTheme(theme) {
    document.body.className = theme === 'default' ? '' : theme;
    localStorage.setItem('bm-theme', theme);
  }
  
  const savedTheme = localStorage.getItem('bm-theme');
  if (savedTheme) setTheme(savedTheme);

  function initBackground() {
    const canvas = document.getElementById('canvas-bg');
    const ctx = canvas.getContext('2d');
    let w, h;
    const particles = [];

    function resize() {
      w = canvas.width = window.innerWidth;
      h = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    for(let i=0; i<80; i++) {
      particles.push({
        x: Math.random() * w, 
        y: Math.random() * h,
        s: Math.random() * 2 + 1,
        v: Math.random() * 0.5 + 0.1
      });
    }

    function draw() {
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = '#00f3ff22';
      particles.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.s, 0, Math.PI*2);
        ctx.fill();
        p.y -= p.v;
        if (p.y < 0) p.y = h;
      });
      requestAnimationFrame(draw);
    }
    draw();
  }

  init();
</script>
</body>
</html>
